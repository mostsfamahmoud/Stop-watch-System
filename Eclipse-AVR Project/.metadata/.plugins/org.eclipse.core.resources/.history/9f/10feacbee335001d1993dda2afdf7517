/******************************************************************************
 * Module: StopWatch Main file
 * File Name: StopWatch.c
 * Description: Source file for The Stop Watch Main File.
 * Author: Mostafa Mahmoud
 * Group:  71
 * Created on: Sep 15, 2022
 *******************************************************************************/


#include "gpio.h"
#include "External_Interrupts.h"
#include "timer.h"


uint8_t g_Sec1 = 0, g_Sec2 = 0;
uint8_t g_Min1 = 0, g_Min2 = 0;
uint8_t g_Hour1 = 0, g_Hour2 = 0;

uint8_t g_Interrupt_Flag = 0;

void StopWatch_Multiplexing_Mode(void);
void resetDigits(void);


int main(void) {

	GPIO_setPortDirection(PORTA_ID, 0x3F); /* Configure (PA0 ... PA5) as O/P pins (Control of the 7 Segment) */

	GPIO_setPortDirection(PORTC_ID, 0x0F); /* Configure (PC0 ... PC3) as O/P pins */

	SET_BIT(SREG, I_BIT); /* Enable global interrupts in MC by setting I-bit */

	INT0_Init(); /* Initialize RESET interrupt */
	INT1_Init(); /* Initialize PAUSE interrupt */
	INT2_Init(); /* Initialize RESUME interrupt */

	Timer1_CTC_Init(); /* Initialize TIMER1 Compare mode */

	while (1)
	{

		StopWatch_Multiplexing_Mode();

		if (g_Interrupt_Flag == 1)
		{
			if (g_Sec1 == 9)
			{
				g_Sec1 = 0;
				g_Sec2++;
			}
			else
				g_Sec1++;

			if ((g_Sec2 == 6) && (g_Sec1 == 0))
			{
				g_Sec2 = 0;
				g_Min1++;
			}

			if ((g_Min1 == 10) && (g_Sec2 == 0) && (g_Sec1 == 0))
			{
				g_Min1 = 0;
				g_Min2++;
			}

			if ((g_Min2 == 6) && (g_Min1 == 0) && (g_Sec2 == 0) && (g_Sec1 == 0))
			{
				g_Min2 = 0;
				g_Hour1++;
			}

			if ((g_Hour1 == 10) && (g_Min2 == 0) && (g_Min1 == 0) && (g_Sec2 == 0) && (g_Sec1 == 0))
			{
				g_Hour1 = 0;
				g_Hour2++;
			}

			if ((g_Hour2 == 2) && (g_Hour1 == 4) && (g_Min2 == 0) && (g_Min1 == 0) && (g_Sec2 == 0) && (g_Sec1 == 0))
			{
				resetDigits();
			}

			g_Interrupt_Flag = 0;
		}
	}

	return 0;
}

void StopWatch_Multiplexing_Mode(void)
{
	SET_BIT(PORTA,PA0);
	PORTC = (PORTC & 0xF0) | g_Sec1;
	_delay_ms(2);

	SET_BIT(PORTA,PA1);
	PORTC = (PORTC & 0xF0) | g_Sec2;
	_delay_ms(2);

	SET_BIT(PORTA,PA2);
	PORTC = (PORTC & 0xF0) | g_Min1;
	_delay_ms(2);

	SET_BIT(PORTA,PA3);
	PORTC = (PORTC & 0xF0) | g_Min2;
	_delay_ms(2);

	SET_BIT(PORTA,PA4);
	PORTC = (PORTC & 0xF0) | g_Hour1;
	_delay_ms(2);

	SET_BIT(PORTA,PA5);
	PORTC = (PORTC & 0xF0) | g_Hour2;
	_delay_ms(2);
}


ISR(TIMER1_COMPA_vect)
{
	g_Interrupt_Flag = 1;
}


/* RESET */
ISR(INT0_vect)
{
	resetDigits();
	PORTC &= 0xF0;
	_delay_ms(10);
}

void resetDigits(void)
{
	g_Sec1 = 0;
	g_Sec2 = 0;
	g_Min1 = 0;
	g_Min2 = 0;
	g_Hour1 = 0;
	g_Hour2 = 0;
}


/* PAUSE */
ISR(INT1_vect)
{
	/* Clock Source OFF (Timer/Counter stopped) */
	CLEAR_BIT(TCCR1B,CS10);
	CLEAR_BIT(TCCR1B,CS11);
	CLEAR_BIT(TCCR1B,CS12);
}


/* RESUME */
ISR(INT2_vect)
{
	/* Clock Source ON again (clkI/O/1024 (From prescaler)) */
	if (BIT_IS_CLEAR(TCCR1B,CS10))
	{
		SET_BIT(TCCR1B,CS10);
	}

	if (BIT_IS_CLEAR(TCCR1B,CS12))
	{
		SET_BIT(TCCR1B,CS12);
	}
}

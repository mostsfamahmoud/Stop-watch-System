/******************************************************************************
 * Module: StopWatch Main file
 * File Name: StopWatch.c
 * Description: Source file for The Stop Watch Main File.
 * Author: Mostafa Mahmoud
 * Group:  71
 * Created on: Sep 15, 2022
 *******************************************************************************/

#include <util/delay.h>
#include "gpio.h"
#include "External_Interrupts.h"

/*******************************************************************************
 *                               GLOBAL VARIABLES                              *
 *******************************************************************************/

uint8_t g_Sec1 = 0, g_Sec2 = 0;       /* Two global variables that represent Seconds count */
uint8_t g_Min1 = 0, g_Min2 = 0;       /* Two global variables that represent Minutes count */
uint8_t g_Hour1 = 0, g_Hour2 = 0;     /* Two global variables that represent Hours count */

uint8_t g_Interrupt_Flag = 0;         /* Flag to be Set if Timer1 interrupt is triggered */

/*******************************************************************************
 *                           FUNCTIONS PROTOTYPES                              *
 *******************************************************************************/

void Timer1_CTC_Init(void);
void StopWatch_Multiplexing_Mode(void);
void StopWatch_TimeProcessing(void);
void resetDigits(void);


int main(void)
{
	GPIO_setPortDirection(PORTA_ID, 0x3F); /* Configure (PA0 ... PA5) as O/P pins (Control of the 7 Segment) */

	GPIO_setPortDirection(PORTC_ID, 0x0F); /* Configure (PC0 ... PC3) as O/P pins */

	SET_BIT(SREG, I_BIT); /* Enable global interrupts in MC by setting I-bit */

	INT0_Init();          /* Initialize INT0 as RESET interrupt */
	INT1_Init();          /* Initialize INT1 as PAUSE interrupt */
	INT2_Init();          /* Initialize INT2 as RESUME interrupt */

	Timer1_CTC_Init();    /* Initialize TIMER1 Compare mode */

	while (1)
	{
		StopWatch_Multiplexing_Mode();

		if (g_Interrupt_Flag == 1)
		{
			StopWatch_TimeProcessing();

			g_Interrupt_Flag = 0;
		}
	}

	return 0;
}

/*******************************************************************************
 *                       STOP-WATCH FUNCTIONS DEFINITIONS                      *
 *******************************************************************************/

void Timer1_CTC_Init(void)
{
	TCNT1 = 0;              /* Set timer1 initial count to zero */

	OCR1A = 977;            /* Set the Compare value to 977 ( To ) */

	TIMSK = (1 << OCIE1A);  /* Enable Timer1 Compare A Interrupt */

	/* Configure timer control register TCCR1A:
	 * 1. Clear OC1A/OC1B on compare match (Set output to low level)
	      COM1A1=1 COM1A0=0 COM1B0=0 COM1B1=1

	 * 2. FOC1A=1 FOC1B=0
	 * 3. CTC Mode WGM10=0 WGM11=0 (Mode Number 4)
	 */
	TCCR1A = (1 << FOC1A) | (1 << COM1A1);

	/* Configure timer control register TCCR1B:
	 * 1. CTC Mode WGM12=1 WGM13=0 (Mode Number 4)
	 * 2. Prescaler = F_CPU/1024
	      CS10=1 CS11=0 CS12=1
	 */
	TCCR1B = (1 << WGM12) | (1 << CS12) | (1 << CS10);
}

/* Function that implement the Multiplexing Mode.
 * Description:
 * One 7-segment display is driven by the Microcontroller at a time and the rest are OFF.
 * It keeps switching the displays using transistors.
 */
void StopWatch_Multiplexing_Mode(void)
{
	/* Array that contains the Stop-Watch digits */
	uint8_t timeDigits[] = {g_Sec1,g_Sec2,g_Min1,g_Min2,g_Hour1,g_Hour2};

	for(uint8_t count = 0; count < 6; count++)
	{

		PORTA = (1 << count);        /* Enable All 7-Segments (one at a time) */

		/* First:  Clearing the display each iteration
		 * Second: Displaying the corresponding count in the enabled 7-Segment
		 */
		PORTC = (PORTC & 0xF0) | timeDigits[count];

		_delay_ms(4);     /* Delay between each 7-segment enable to make the Stop-Watch display looks normal */
	}
}

void StopWatch_TimeProcessing(void)
{
	if (g_Sec1 == 9)
	{
		g_Sec1 = 0;
		g_Sec2++;
	}
	else
		g_Sec1++;

	if ((g_Sec2 == 6) && (g_Sec1 == 0))
	{
		g_Sec2 = 0;
		g_Min1++;
	}

	if ((g_Min1 == 10) && (g_Sec2 == 0) && (g_Sec1 == 0))
	{
		g_Min1 = 0;
		g_Min2++;
	}

	if ((g_Min2 == 6) && (g_Min1 == 0) && (g_Sec2 == 0) && (g_Sec1 == 0))
	{
		g_Min2 = 0;
		g_Hour1++;
	}

	if ((g_Hour1 == 10) && (g_Min2 == 0) && (g_Min1 == 0) && (g_Sec2 == 0) && (g_Sec1 == 0))
	{
		g_Hour1 = 0;
		g_Hour2++;
	}

	if ((g_Hour2 == 10) && (g_Hour1 == 0) && (g_Min2 == 0) && (g_Min1 == 0) && (g_Sec2 == 0) && (g_Sec1 == 0))
	{
		g_Hour2 = 0;
	}
}

/* Function to reset all Stop-Watch Digits */
void resetDigits(void)
{
	g_Sec1 = 0, g_Sec2 = 0;
	g_Min1 = 0, g_Min2 = 0;
	g_Hour1 = 0, g_Hour2 = 0;
}


/*******************************************************************************
 *                          INTERRUPT SERVICE ROUTINES                         *
 *******************************************************************************/

ISR(TIMER1_COMPA_vect)
{
	g_Interrupt_Flag = 1;
}


/* INT0 (ISR) that is responsible for RESET the Stop-Watch timer */
ISR(INT0_vect)
{
	resetDigits();
	PORTC &= 0xF0;
	_delay_ms(30);
}


/* INT1 (ISR) that is responsible for PAUSE the Stop-Watch timer */
ISR(INT1_vect)
{
	/* Configure timer control register TCCR1B:
	 * No clock source (Timer/Counter stopped)
	      CS10=0 CS11=0 CS12=0
	 */
	CLEAR_BIT(TCCR1B,CS10);
	CLEAR_BIT(TCCR1B,CS11);
	CLEAR_BIT(TCCR1B,CS12);
}


/* INT2 (ISR) that is responsible for RESUME the Stop-Watch timer if it is paused */
ISR(INT2_vect)
{
	/* Configure timer control register TCCR1B:
	 * Clock Source ON again (F_CLK/1024 (From prescaler))
	      CS10=1 CS11=0 CS12=1
	 */

	/* Check if bit (CS10) in register (TCCR1B) is cleared or not */
	if (BIT_IS_CLEAR(TCCR1B,CS10))
	{
		SET_BIT(TCCR1B,CS10);
	}

	/* Check if bit (CS12) in register (TCCR1B) is cleared or not */
	if (BIT_IS_CLEAR(TCCR1B,CS12))
	{
		SET_BIT(TCCR1B,CS12);
	}
}
